import casadi as ca
import numpy as np

# Define parameters
Q = np.diag([12.5, 12.5])
R = np.diag([12.5, 0.05])
P = np.diag([12.5, 12.5])
N = 60
D = 0.3
epsilon_g = 0.2
epsilon_r = 0.05
epsilon_o = 0.05
kr = 10e6
ko = 10e6

# Define dimensions
n = 2  # state dimension
m = 2  # control dimension
na = 2  # number of agents
no = 2  # number of obstacles

# Define symbolic variables
x = ca.SX.sym('x', n, N+1, na)
u = ca.SX.sym('u', m, N, na)
delta_r = ca.SX.sym('delta_r', 1)
delta_o = ca.SX.sym('delta_o', 1)

# Define dynamics for each agent (example: simple integrator dynamics)
f = lambda x, u: x + u

# Example reference path (this should be generated by a high-level planner)
# Here we use a simple linear path as an example
r = np.zeros((n, N+1, na))
for i in range(na):
    r[:, :, i] = np.linspace([0, 0], [1, 1], N+1).T

# Convert reference path to CasADi DM
r_dm = []
for i in range(na):
    r_dm.append(ca.DM(r[:, :, i].tolist()))

# Define the objective function
J = 0
for i in range(na):
    for k in range(N):
        J += ca.mtimes([(x[:, k, i] - r_dm[i][:, k]).T, Q, (x[:, k, i] - r_dm[i][:, k])]) + ca.mtimes([u[:, k, i].T, R, u[:, k, i]])
    J += ca.mtimes([x[:, N, i].T, P, x[:, N, i]])

J += kr * delta_r + ko * delta_o

# Define constraints
g = []
for i in range(na):
    for k in range(N):
        # Dynamics constraint
        g.append(x[:, k+1, i] - f(x[:, k, i], u[:, k, i]))
        
        # Inter-agent collision avoidance
        for j in range(na):
            if i != j:
                g.append(ca.norm_2(x[:, k, i] - x[:, k, j]) - (D + delta_r + epsilon_r))
        
        # Obstacle avoidance
        for p in range(no):
            g.append(ca.norm_2(x[:, k, i] - ca.DM([0.5, 0.5])) - (D/2 + delta_o + epsilon_o))  # Example static obstacle

# Flatten the constraints and states
g = ca.vertcat(*g)
x_flat = ca.vertcat(*[x[:,:,i].reshape((-1,1)) for i in range(na)])
u_flat = ca.vertcat(*[u[:,:,i].reshape((-1,1)) for i in range(na)])

# Define optimization variables
opts_vars = ca.vertcat(x_flat, u_flat, delta_r, delta_o)

# Define bounds (example values, these should be problem specific)
lbx = -ca.inf * ca.DM.ones(opts_vars.shape)
ubx = ca.inf * ca.DM.ones(opts_vars.shape)
lbg = 0
ubg = 0

# Define initial guess (example values, these should be problem specific)
x0 = ca.DM.zeros(opts_vars.shape)

# Create NLP solver
nlp = {'x': opts_vars, 'f': J, 'g': g}
opts = {'ipopt.print_level': 0, 'print_time': 0}
solver = ca.nlpsol('solver', 'ipopt', nlp, opts)

# Solve the optimization problem
sol = solver(x0=x0, lbx=lbx, ubx=ubx, lbg=lbg, ubg=ubg)

# Extract the optimal solution
x_opt = sol['x']
print("Optimal solution:", x_opt)
